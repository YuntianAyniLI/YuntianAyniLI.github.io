// 核心排版循环
            let blockIndex = 0;
            while (blocks.length > 0) {
                let block = blocks.shift(); // 取出队列中的第一个块
                blockIndex++;
                
                const blockPreview = block.textContent.substring(0, 20).replace(/\s+/g, '');
                console.log(`\n处理第 ${blockIndex} 个块: "${blockPreview}..."`);

                // 1. 处理强制换列逻辑 (class="break-to-left")
                // 如果块要求从左边开始，且当前还在右边，则强制切换
                if (block.classList.contains('break-to-left') && targetContainer === currentRight) {
                    console.log('  → 强制切换到左侧');
                    targetContainer = currentLeft;
                }

                // 2. 尝试将块放入当前容器
                const containerSide = targetContainer === currentRight ? '右侧' : '左侧';
                console.log(`  → 放入${containerSide}容器`);
                targetContainer.appendChild(block);

                // 3. 检测是否溢出或碰撞
                let overflowType = checkOverflowOrCollision(block, targetContainer, currentPage);

                if (overflowType) {
                    console.log('  ❌ 检测到溢出:', overflowType);
                    console.log('     容器宽度:', targetContainer.clientWidth, '滚动宽度:', targetContainer.scrollWidth);
                    
                    // 如果发生溢出，尝试递归切分
                    let remainder = recursiveSplit(block, targetContainer, currentPage);
                    
                    if (remainder) {
                        console.log('  ✂️ 切分成功，剩余:', remainder.textContent.substring(0, 20));
                        // 如果切分成功（即留了一部分在当前页，切下来一部分 remainder）
                        
                        // 移除 remainder 上的强制换列标记，防止在下一页重复触发换列
                        remainder.classList.remove('break-to-left');
                        
                        // 将剩余部分放回队列头部，等待下一次循环处理
                        blocks.unshift(remainder);
                        
                        // 既然当前容器已满（切分了），切换到下一个容器
                        switchToNextContainer();
                        console.log('  → 切换容器');<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>李韵天 | Yuntian LI</title>
    
    <style>
    
        
    /* ================= 1. 字体与变量 ================= */
    @font-face {
        font-family: 'ZYSongKeBen';
        src: url('fonts/ZYSongKeBen.otf') format('opentype');
        font-weight: normal; font-style: normal; font-display: swap;
    }

    :root {
        --theme-purple: #500650; 
        --theme-red: #d43628;    
        --paper-bg: #fdfbf7;     
        --outer-border: 4px;     
        --inner-border: 1px;     
        --char-spacing: 0.45em;  
        --col-gap: 3.0em; 
    }

    /* ================= 2. 基础布局 ================= */
    body {
        margin: 0; padding: 60px 0;
        background-color: var(--paper-bg); 
        font-family: 'ZYSongKeBen', "Times New Roman", serif;
        display: flex; flex-direction: column; align-items: center;
        min-height: 100vh;
        gap: 60px; 
        overflow-x: hidden;
    }

    /* ================= 3. 页面容器 (16:9) ================= */
    .ancient-page {
        height: 85vh; 
        aspect-ratio: 16 / 9; 
        background-color: var(--paper-bg);
        position: relative; 
        flex-shrink: 0; 
        border: var(--outer-border) solid var(--theme-purple); 
        box-shadow: 0 20px 50px rgba(80, 6, 80, 0.1); 
        box-sizing: border-box;
    }

    .inner-border-box {
        position: absolute;
        top: 12px; bottom: 12px; left: 12px; right: 12px;
        border: var(--inner-border) solid var(--theme-purple);
        pointer-events: none; z-index: 1;
    }

    /* 【新增】禁止换行容器 (强力胶水) */
    .no-break {
        white-space: nowrap; 
        display: inline;
    }

    /* ================= 4. 版心 ================= */
    .banxin-container {
        writing-mode: horizontal-tb;
        position: absolute;
        left: 50%; top: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
        display: flex; flex-direction: column;
        align-items: center; justify-content: center;
        gap: 0.6em; 
    }

    .thick-line {
        width: 3.5em; height: var(--outer-border);
        background-color: var(--theme-purple);
        border-radius: 0;
    }
    .thin-line {
        width: 3.5em; height: 1px;
        background-color: var(--theme-purple);
    }
    .bottom-lines-wrapper {
        display: flex; flex-direction: column; gap: 1px;
    }
    .banxin-name {
        writing-mode: vertical-rl;
        font-size: 1.8em; font-weight: bold;
        color: var(--theme-purple);
        letter-spacing: 0.6em; padding: 0.2em 0;
    }

    /* ================= 5. 内容填充区 ================= */
    .content-half {
        position: absolute;
        top: 10vh; bottom: 10vh;
        z-index: 5;
        writing-mode: vertical-rl;
        text-orientation: upright;
        display: flex;
        flex-wrap: wrap; 
        align-content: flex-start; 
        gap: var(--col-gap);
        width: auto;
        max-width: 40%;
    }

    .content-right {
        right: 4vh; 
        left: auto; 
    }

    .content-left {
        right: 50%; 
        padding-right: 4em; 
        left: auto; 
    }

    /* ================= 6. 文本单元样式 ================= */
    .content-block {
        font-size: 2.25vh;
        line-height: 2.2;
        letter-spacing: var(--char-spacing);
        color: black;
        position: relative;
        /* 允许断裂 */
        break-inside: auto; 
    }

    .section-title {
        font-weight: bold; font-size: 1.3em;
        color: var(--theme-purple);
        margin-left: 0.5em; 
    }

    .project-title {
        font-weight: bold; font-size: 1em;
        color: var(--theme-purple);
        display: block; margin-bottom: 0.3em;
    }

    .project-content {
        color: black; font-size: 1em;
    }

    a { text-decoration: none; color: black; border-bottom: none; }
    a:hover { color: var(--theme-purple); }

    .ge-zhu {
        display: inline-block; 
        font-weight: bold; font-size: 0.6em; 
        line-height: 1.2; 
        color: var(--theme-purple);
        margin: 0 0.1em;
        text-align: left;
        text-align-last: left; 
        vertical-align: text-bottom; 
        position: relative;
        left: -0.5em; 
    }
        
    /* ================= 7. 旁注标点 ================= */
    .punct-wrapper {
        position: relative; display: inline; width: 0; height: 0;
    }
    .punct {
        position: absolute;
        width: 0.45em; height: 0.45em;
        left: 0.85em;   
        top: -0.6em;     
        pointer-events: none; z-index: 20;
    }
    .punct-dun {
        background-color: var(--theme-red);
        width: 0.35em; height: 0.6em;
        border-radius: 0 100% 100% 100%;
        transform: rotate(-15deg);
        margin-top: -0.1em;
    }
    .punct-period {
        width: 0.45em; height: 0.45em;
        border: 2px solid var(--theme-red);
        border-radius: 50%;
        background-color: transparent;
        box-sizing: border-box; 
    }

    /* ================= 8. 女书图片 ================= */
    .nushu-stamp {
        position: absolute;
        left: 25px; bottom: 25px;
        z-index: 20; width: 55px; 
        pointer-events: auto; 
    }
    .nushu-img {
        width: 100%; height: auto;
        opacity: 0.8; transition: opacity 0.3s; cursor: pointer;
    }
    .nushu-img:hover { opacity: 1; }

    /* ================= 9. 内容源 ================= */
    #source-content { display: none; }
    </style>
</head>
<body>

    <div id="source-content">
        
        <div class="content-block">
            <span class="section-title">你好</span>
        </div>

        <div class="content-block">
            <span>
                我是斯德哥尔摩大学经济学博士生。我于二零二四年获得中国人民大学经济学<span class="ge-zhu">金融<br>方向</span>和数学与应用数学学士学位。
            </span>
        </div>

        <div class="content-block">
            <span>
                我的研究兴趣在于政治经济学<span class="ge-zhu">法经济学<br>政治理论</span>与计算宏观<span class="ge-zhu">异质性代理人<br>货币政策</span>。
            </span>
        </div>

        <div class="content-block break-to-left">
            <span class="section-title">创作</span>
        </div>

        <div class="content-block">
            <a href="#" class="project-title">项目壹</a>
            <div class="project-content">
                这里是一个量化历史项目。我们关注雍正时期的权力集中和政治清洗问题。
            </div>
        </div>

        <div class="content-block">
            <a href="#" class="project-title">项目标题贰</a>
            <div class="project-content">
                这里应当是另一个我的独立量化历史项目。我关心民国时期的文艺活动。电影诞生于十九世纪末，广受欢迎于二十世纪。由于电影的现实性，幻觉性，逼真性及其时空扩展的无限性，电影银幕展现的大千世界可谓无所不包，对观众的影响因而更为直观与形象。正是由于电影强大的社会影响力，社会各界对电影的关注远远超过他种艺术形式，并往往越出纯艺术范畴之外，而与当时的社会，政治，文化，民俗背景密切相关。电影检查制度就是这种大背景之下的产物。随着电影业的发展及其影响的不断扩大，各种宽严不一的电影检查制度也在世界各国先后出现，并随着时代的发展和国情的差别，变化着其不同的内容与表现形式。
            </div>
        </div>

        <div class="content-block">
            <a href="#" class="project-title">项目标题三</a>
            <div class="project-content">
                这可能是一个和宏观模型相关的东西。
            </div>
        </div>

        
        
         <div class="content-block">
            <a href="#" class="project-title">项目标题陆</a>
            <div class="project-content">
                这是更多内容的测试，确保它能顺滑地排布到下一页去，并且总是从右边开始写。
            </div>
        </div>

    </div>

    <div id="book-container"></div>


    <script>
        document.addEventListener("DOMContentLoaded", function() {
            console.log('页面开始加载');
            layoutBook();
            styleAllPunctuation();
            console.log('页面加载完成');
        });

        function layoutBook() {
            console.log('开始排版');
            const source = document.getElementById('source-content');
            const bookContainer = document.getElementById('book-container');
            // 克隆所有节点，避免修改源
            let blocks = Array.from(source.children).map(node => node.cloneNode(true));
            console.log('总共有', blocks.length, '个块需要排版');

            // 创建新页面模板函数
            function createNewPage() {
                const page = document.createElement('div');
                page.className = 'ancient-page';
                page.innerHTML = `
                    <div class="inner-border-box"></div>
                    <div class="banxin-container">
                        <div class="thick-line"></div>
                        <div class="banxin-name">李韵天</div>
                        <div class="bottom-lines-wrapper">
                            <div class="thin-line"></div>
                            <div class="thick-line"></div>
                        </div>
                    </div>
                    <div class="content-half content-right"></div>
                    <div class="content-half content-left"></div>
                    <div class="nushu-stamp">
                        <a href="index.html">
                            <img src="https://raw.githubusercontent.com/YuntianAyniLI/YuntianAyniLI.github.io/main/NametaginNyuShu.png" alt="English" class="nushu-img">
                        </a>
                    </div>
                `;
                bookContainer.appendChild(page);
                return page;
            }

            // 初始化第一页
            let currentPage = createNewPage();
            let currentRight = currentPage.querySelector('.content-right');
            let currentLeft = currentPage.querySelector('.content-left');
            
            // 初始填充目标为右侧
            let targetContainer = currentRight;

            // 切换到下一个容器的辅助函数
            function switchToNextContainer() {
                if (targetContainer === currentRight) {
                    // 如果当前在右边，切换到左边
                    targetContainer = currentLeft;
                } else {
                    // 如果当前在左边，创建新页面，并切换到新页面的右边
                    currentPage = createNewPage();
                    currentRight = currentPage.querySelector('.content-right');
                    currentLeft = currentPage.querySelector('.content-left');
                    targetContainer = currentRight;
                }
            }

            // 核心排版循环
            while (blocks.length > 0) {
                let block = blocks.shift(); // 取出队列中的第一个块

                // 1. 处理强制换列逻辑 (class="break-to-left")
                // 如果块要求从左边开始，且当前还在右边，则强制切换
                if (block.classList.contains('break-to-left') && targetContainer === currentRight) {
                    targetContainer = currentLeft;
                }

                // 2. 尝试将块放入当前容器
                targetContainer.appendChild(block);

                // 3. 检测是否溢出或碰撞
                let overflowType = checkOverflowOrCollision(block, targetContainer, currentPage);

                if (overflowType) {
                    console.log('检测到溢出:', overflowType, '块内容:', block.textContent.substring(0, 50));
                    console.log('容器宽度:', targetContainer.clientWidth, '滚动宽度:', targetContainer.scrollWidth);
                    
                    // 如果发生溢出，尝试递归切分
                    let remainder = recursiveSplit(block, targetContainer, currentPage);
                    
                    if (remainder) {
                        console.log('切分成功，剩余内容:', remainder.textContent.substring(0, 30));
                        // 如果切分成功（即留了一部分在当前页，切下来一部分 remainder）
                        
                        // 移除 remainder 上的强制换列标记，防止在下一页重复触发换列
                        remainder.classList.remove('break-to-left');
                        
                        // 将剩余部分放回队列头部，等待下一次循环处理
                        blocks.unshift(remainder);
                        
                        // 既然当前容器已满（切分了），切换到下一个容器
                        switchToNextContainer();
                    } else {
                        console.log('切分失败，整体移动块');
                        // 如果切分结果为 null，说明这个块连一个字都放不下
                        // 此时只能将整个块从当前容器移除
                        targetContainer.removeChild(block);
                        
                        // 切换到下一个容器
                        switchToNextContainer();
                        
                        // 将原块放回队列，在新的容器中重新尝试
                        blocks.unshift(block);
                    }
                }
            }
        }

        function checkOverflowOrCollision(block, container, page) {
            const tolerance = 15; // 增加容差，避免因测量误差导致的误判
            if (container.scrollWidth > container.clientWidth + tolerance) {
                return 'width';
            }
            if (container.classList.contains('content-left')) {
                const nodeRect = block.getBoundingClientRect();
                const pageRect = page.getBoundingClientRect();
                const distanceToLeft = nodeRect.left - pageRect.left;
                const distanceToBottom = pageRect.bottom - nodeRect.bottom;
                // 图片危险区域
                if (distanceToLeft < 100 && distanceToBottom < 115) {
                    return 'collision';
                }
            }
            return null;
        }

        // 递归切分函数：深入元素内部切分文字
        function recursiveSplit(node, container, page) {
            // 如果当前节点已经不再导致溢出，说明切分完成，不需要再切了，返回 null
            if (!checkOverflowOrCollision(node, container, page)) {
                return null;
            }

            // 【新增】检查是否只是轻微溢出（容差 10px）
            // 如果只是轻微溢出，可能是测量误差，不应该切分
            const overflowAmount = container.scrollWidth - container.clientWidth;
            console.log('    溢出量:', overflowAmount, 'px');
            if (overflowAmount < 10) {
                console.log('    溢出量小于10px，忽略');
                return null;
            }

            // 准备存放剩余内容的容器（浅拷贝节点结构，复制标签名、类名等）
            let remainder = node.cloneNode(false);
            // 移除 id 避免重复
            remainder.removeAttribute('id');
            
            console.log('    开始切分节点:', node.nodeName, node.className);
            
            // 存放切下来的节点（倒序堆栈）
            let extractedNodes = [];

            // 循环：只要当前块还在溢出，就持续从末尾移除内容
            // 我们从后往前删，直到刚好能放下
            let iterationCount = 0;
            while (checkOverflowOrCollision(node, container, page)) {
                iterationCount++;
                if (iterationCount > 500) {
                    console.error('    切分循环超过500次，强制退出');
                    break;
                }
                
                let lastChild = node.lastChild;
                
                // 如果当前节点被删空了，说明这个 node 在这里一点都放不下
                if (!lastChild) {
                    console.log('    节点已空，切分失败');
                    // 从容器中移除这个空壳
                    if (node.parentNode) node.parentNode.removeChild(node);
                    // 返回 null，告诉上层逻辑"切分失败，请整体移动"
                    return null; 
                }

                // --- 情况 A: 元素节点 (Element) ---
                if (lastChild.nodeType === 1) { 
                    console.log('      处理元素节点:', lastChild.nodeName, lastChild.className);
                    // 【关键逻辑】检查是否为"不可断行"的胶水容器 (.no-break)
                    // 这是我们在 styleAllPunctuation 中生成的 [汉字+标点] 组合
                    if (lastChild.classList.contains('no-break')) {
                        // 这是一个原子组合，严禁拆分！
                        // 直接整体移走
                        console.log('      → no-break 容器，整体移动');
                        node.removeChild(lastChild);
                        extractedNodes.unshift(lastChild);
                    }
                    // 普通元素（如 span, div, a），尝试深入内部切分
                    else {
                        // 只有当它有子节点时才尝试深入
                        if (lastChild.childNodes.length > 0) {
                            console.log('      → 深入元素内部切分');
                            let grandChild = lastChild.lastChild;
                            
                            // --- 处理孙子节点 (GrandChild) ---
                            if (grandChild.nodeType === 3) { // 孙子是文本
                                let gText = grandChild.nodeValue;
                                // 【关键修复】先去除尾部的空白字符
                                gText = gText.replace(/\s+$/, '');
                                grandChild.nodeValue = gText;
                                
                                if (gText.length > 0) {
                                    // 切一个字
                                    let char = gText.slice(-1); 
                                    grandChild.nodeValue = gText.slice(0, -1);
                                    console.log('      → 切出文字:', char);
                                    
                                    // 为了保持结构，准备一个和 lastChild 一样的"壳子"
                                    let wrapper;
                                    
                                    // 检查 extractedNodes 的第一个元素是否已经是这个壳子
                                    if (extractedNodes.length > 0 && 
                                        extractedNodes[0].nodeName === lastChild.nodeName && 
                                        extractedNodes[0].className === lastChild.className) {
                                        wrapper = extractedNodes[0];
                                    } else {
                                        wrapper = lastChild.cloneNode(false);
                                        wrapper.removeAttribute('id');
                                        extractedNodes.unshift(wrapper);
                                    }
                                    
                                    // 把切下来的字插入 wrapper 的最前面
                                    if (wrapper.firstChild) {
                                        wrapper.insertBefore(document.createTextNode(char), wrapper.firstChild);
                                    } else {
                                        wrapper.appendChild(document.createTextNode(char));
                                    }
                                    
                                    // 如果切完后孙子空了，移除孙子
                                    if (grandChild.nodeValue.length === 0) {
                                        lastChild.removeChild(grandChild);
                                    }
                                } else {
                                    // 空文本节点或只有空白，移除
                                    lastChild.removeChild(grandChild);
                                }
                            } else { 
                                // 孙子是元素（比如更深层的标签，或者是 no-break），直接移走整个孙子
                                console.log('      → 孙子是元素，整体移动');
                                lastChild.removeChild(grandChild);
                                
                                // 为了保持结构，准备一个和 lastChild 一样的"壳子"
                                let wrapper;
                                if (extractedNodes.length > 0 && 
                                    extractedNodes[0].nodeName === lastChild.nodeName && 
                                    extractedNodes[0].className === lastChild.className) {
                                    wrapper = extractedNodes[0];
                                } else {
                                    wrapper = lastChild.cloneNode(false);
                                    wrapper.removeAttribute('id');
                                    extractedNodes.unshift(wrapper);
                                }
                                
                                if (wrapper.firstChild) {
                                    wrapper.insertBefore(grandChild, wrapper.firstChild);
                                } else {
                                    wrapper.appendChild(grandChild);
                                }
                            }
                            
                            // 如果 lastChild 被清空了，移除它
                            if (lastChild.childNodes.length === 0) {
                                node.removeChild(lastChild);
                            }
                        } else {
                            // 空元素，直接移走
                            console.log('      → 空元素，移走');
                            node.removeChild(lastChild);
                            extractedNodes.unshift(lastChild);
                        }
                    }
                } 
                // --- 情况 B: 文本节点 (Text) ---
                else if (lastChild.nodeType === 3) { 
                    let text = lastChild.nodeValue;
                    // 【关键修复】先去除尾部的空白字符
                    text = text.replace(/\s+$/, '');
                    lastChild.nodeValue = text;
                    
                    if (text.length > 0) {
                        // 切一个字
                        let char = text.slice(-1);
                        lastChild.nodeValue = text.slice(0, -1);
                        console.log('      → 切出文字(顶层):', char);
                        extractedNodes.unshift(document.createTextNode(char));
                        
                        if (lastChild.nodeValue.length === 0) {
                            node.removeChild(lastChild);
                        }
                    } else {
                        // 空文本节点或只有空白，移除
                        node.removeChild(lastChild);
                    }
                }
            }

            console.log('    切分完成，共切出', extractedNodes.length, '个节点');

            // 组装 remainder (剩余部分)
            if (extractedNodes.length > 0) {
                extractedNodes.forEach(child => remainder.appendChild(child));
                console.log('    remainder 内容:', remainder.textContent.substring(0, 30));
                return remainder;
            }
            
            // 理论上走不到这里，但作为保险
            return null;
        }

        function styleAllPunctuation() {
            const wrappers = document.querySelectorAll('.content-block, .project-content');
            wrappers.forEach(container => {
                processNode(container);
            });

            function processNode(node) {
                // 递归处理元素节点，但跳过已经被我们包裹的元素，防止无限递归
                if (node.nodeType === 1 && !node.classList.contains('punct-wrapper') && !node.classList.contains('no-break')) {
                    Array.from(node.childNodes).forEach(processNode);
                } 
                // 处理文本节点
                else if (node.nodeType === 3) { 
                    const text = node.nodeValue;
                    
                    // 正则修改：同时捕获 [前一个字] 和 [标点]
                    // ([^，、。]?) 捕获标点前的一个非标点字符（可能是空，如果是开头）
                    // ([，、。]) 捕获标点本身
                    const regex = /([^，、。]?)([，、。])/g; 
                    
                    if (regex.test(text)) {
                        const fragment = document.createDocumentFragment();
                        let lastIndex = 0;
                        
                        text.replace(regex, function(match, prevChar, char, index) {
                            // 1. 添加 [前一个字] 之前的所有普通文本
                            const textBefore = text.slice(lastIndex, index);
                            if (textBefore) fragment.appendChild(document.createTextNode(textBefore));
                            
                            // 2. 创建胶水容器 (No Break)，禁止内部换行
                            const glueSpan = document.createElement('span');
                            glueSpan.className = 'no-break';
                            
                            // 3. 把 [前一个字] 放进胶水容器 (如果有的话)
                            if (prevChar) {
                                glueSpan.appendChild(document.createTextNode(prevChar));
                            }
                            
                            // 4. 创建标点 Wrapper (用于定位和样式)
                            const wrapper = document.createElement('span');
                            wrapper.className = 'punct-wrapper';
                            const punctSpan = document.createElement('span');
                            punctSpan.className = 'punct';
                            
                            if (char === '。') {
                                punctSpan.classList.add('punct-period');
                            } else {
                                punctSpan.classList.add('punct-dun');
                            }
                            
                            wrapper.appendChild(punctSpan);
                            
                            // 5. 把标点也放进胶水容器
                            glueSpan.appendChild(wrapper);
                            
                            // 6. 将胶水容器添加到文档流
                            fragment.appendChild(glueSpan);
                            
                            // 更新索引
                            lastIndex = index + match.length;
                        });
                        
                        // 添加剩余文本
                        const remainingText = text.slice(lastIndex);
                        if (remainingText) fragment.appendChild(document.createTextNode(remainingText));
                        
                        // 替换原始文本节点
                        node.parentNode.replaceChild(fragment, node);
                    }
                }
            }
        }

            
                     
    </script>
</body>
</html>
