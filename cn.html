<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>李韵天 | Yuntian LI</title>
    
    <style>
    /* ================= 1. 字体与变量 ================= */
    @font-face {
        font-family: 'ZYSongKeBen';
        src: url('fonts/ZYSongKeBen.otf') format('opentype');
        font-weight: normal; font-style: normal; font-display: swap;
    }

    :root {
        --theme-purple: #500650; 
        --theme-red: #d43628;    
        --paper-bg: #fdfbf7;     
        --outer-border: 4px;     
        --inner-border: 1px;     
        --char-spacing: 0.45em;  
        --col-gap: 3.0em; 
    }

    /* ================= 2. 基础布局 ================= */
    body {
        margin: 0; padding: 60px 0;
        background-color: var(--paper-bg); 
        font-family: 'ZYSongKeBen', "Times New Roman", serif;
        display: flex; flex-direction: column; align-items: center;
        min-height: 100vh;
        gap: 60px; 
        overflow-x: hidden;
    }

    /* ================= 3. 页面容器 (16:9) ================= */
    .ancient-page {
        height: 85vh; 
        aspect-ratio: 16 / 9; 
        background-color: var(--paper-bg);
        position: relative; 
        flex-shrink: 0; 
        border: var(--outer-border) solid var(--theme-purple); 
        box-shadow: 0 20px 50px rgba(80, 6, 80, 0.1); 
        box-sizing: border-box;
    }

    .inner-border-box {
        position: absolute;
        top: 12px; bottom: 12px; left: 12px; right: 12px;
        border: var(--inner-border) solid var(--theme-purple);
        pointer-events: none; z-index: 1;
    }

    /* ================= 4. 版心 ================= */
    .banxin-container {
        writing-mode: horizontal-tb;
        position: absolute;
        left: 50%; top: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
        display: flex; flex-direction: column;
        align-items: center; justify-content: center;
        gap: 0.6em; 
    }

    .thick-line {
        width: 3.5em; height: var(--outer-border);
        background-color: var(--theme-purple);
        border-radius: 0;
    }
    .thin-line {
        width: 3.5em; height: 1px;
        background-color: var(--theme-purple);
    }
    .bottom-lines-wrapper {
        display: flex; flex-direction: column; gap: 1px;
    }
    .banxin-name {
        writing-mode: vertical-rl;
        font-size: 1.8em; font-weight: bold;
        color: var(--theme-purple);
        letter-spacing: 0.6em; padding: 0.2em 0;
    }

    /* ================= 5. 内容填充区 ================= */
    .content-half {
        position: absolute;
        top: 10vh; bottom: 10vh;
        z-index: 5;
        writing-mode: vertical-rl;
        text-orientation: upright;
        display: flex;
        flex-wrap: wrap; 
        align-content: flex-start; 
        gap: var(--col-gap);
        width: auto;
        max-width: 40%;
    }

    .content-right {
        right: 4vh; 
        left: auto; 
    }

    .content-left {
        right: 50%; 
        padding-right: 4em; 
        left: auto; 
        /* 【核心修改】增加左侧留白，让文字距离左边框更宽一点 */
        padding-left: 5vh; 
    }

    /* ================= 6. 文本单元样式 ================= */
    .content-block {
        font-size: 2.25vh;
        line-height: 2.2;
        letter-spacing: var(--char-spacing);
        color: black;
        position: relative;
        /* 允许内部断裂，这是流式排版的基础 */
        break-inside: auto; 
    }

    .section-title {
        font-weight: bold; font-size: 1.3em;
        color: var(--theme-purple);
        margin-left: 0.5em; 
    }

    .project-title {
        font-weight: bold; font-size: 1em;
        color: var(--theme-purple);
        display: block; margin-bottom: 0.3em;
    }

    .project-content {
        color: black; font-size: 1em;
    }

    a { text-decoration: none; color: black; border-bottom: none; }
    a:hover { color: var(--theme-purple); }

    .ge-zhu {
        display: inline-block; 
        font-weight: bold; font-size: 0.6em; 
        line-height: 1.2; 
        color: var(--theme-purple);
        margin: 0 0.1em;
        text-align: left;
        text-align-last: left; 
        vertical-align: text-bottom; 
        position: relative;
        left: -0.45em; 
    }
        
    /* ================= 7. 旁注标点 ================= */
    .punct-wrapper {
        position: relative; display: inline; width: 0; height: 0;
    }
    .punct {
        position: absolute;
        width: 0.45em; height: 0.45em;
        left: 0.85em;   
        top: -0.6em;     
        pointer-events: none; z-index: 20;
    }
    .punct-dun {
        background-color: var(--theme-red);
        width: 0.35em; height: 0.6em;
        border-radius: 0 100% 100% 100%;
        transform: rotate(-15deg);
        margin-top: -0.1em;
    }
    .punct-period {
        width: 0.45em; height: 0.45em;
        border: 2px solid var(--theme-red);
        border-radius: 50%;
        background-color: transparent;
        box-sizing: border-box; 
    }

    /* ================= 8. 女书图片 ================= */
    .nushu-stamp {
        position: absolute;
        left: 25px; bottom: 25px;
        z-index: 20; width: 55px; 
        pointer-events: auto; 
    }
    .nushu-img {
        width: 100%; height: auto;
        opacity: 0.8; transition: opacity 0.3s; cursor: pointer;
    }
    .nushu-img:hover { opacity: 1; }

    /* ================= 9. 内容源 ================= */
    #source-content { display: none; }
    </style>
</head>
<body>

    <div id="source-content">
        
        <div class="content-block">
            <span class="section-title">你好</span>
        </div>

        <div class="content-block">
            <span>
                我是斯德哥尔摩大学经济学博士生。我于二零二四年获得中国人民大学经济学<span class="ge-zhu">金融<br>方向</span>和数学与应用数学学士学位，于二零二七年获得斯德哥尔摩大学法学<span class="ge-zhu">欧洲经济法方向<br>归于少司命楼梦茜</span>硕士学位。
            </span>
        </div>

        <div class="content-block">
            <span>
                我的研究兴趣在于政治经济学<span class="ge-zhu">法经济学<br>政治理论</span>与计算宏观<span class="ge-zhu">异质性代理人<br>货币政策</span>。
            </span>
        </div>

        <div class="content-block break-to-left">
            <span class="section-title">创作</span>
        </div>

        <div class="content-block">
            <a href="#" class="project-title">项目标题壹</a>
            <div class="project-content">
                此处为项目壹的简短摘要。这是关于宏观经济模型的讨论。
            </div>
        </div>

        <div class="content-block">
            <a href="#" class="project-title">项目标题贰</a>
            <div class="project-content">
                项目贰的摘要，更多关于数据的分析。
            </div>
        </div>

        <div class="content-block">
            <a href="#" class="project-title">项目标题三</a>
            <div class="project-content">
                关于货币政策的历史演变，基于面板数据的实证研究。
            </div>
        </div>

        <div class="content-block">
            <a href="#" class="project-title">项目标题肆</a>
            <div class="project-content">
                制度经济学视角的思考，工作论文草稿。
            </div>
        </div>

        <div class="content-block">
            <a href="#" class="project-title">项目标题伍</a>
            <div class="project-content">
                关于动态随机一般均衡模型，代码库与数据集。这是一个非常长的测试段落，用来验证当文字遇到页面边缘或者遇到左下角的图片时，是否能够自动断开。如果文字撞到了图片，它应该在图片上方停止，然后剩余的文字自动流转到下一页的起始位置（右侧）继续书写，保持阅读的连续性，而不是生硬地换页或者遮挡图片。这需要非常精确的计算。继续长长长长长长长长长长长长，长长长长长长长长，长长长长长长长长长长长长长长长长长。长长长长长长长长长的测试
            </div>  
        </div>
        
         <div class="content-block">
            <a href="#" class="project-title">项目标题陆</a>
            <div class="project-content">
                这是更多内容的测试，确保它能顺滑地排布到下一页去，并且总是从右边开始写。
            </div>
        </div>

    </div>

    <div id="book-container"></div>


    <script>
        document.addEventListener("DOMContentLoaded", function() {
            layoutBook();
            styleAllPunctuation();
        });

        function layoutBook() {
            const source = document.getElementById('source-content');
            const bookContainer = document.getElementById('book-container');
            // 将节点列表转换为数组，方便操作
            let blocks = Array.from(source.children).map(node => node.cloneNode(true));

            // 创建新页面模板
            function createNewPage() {
                const page = document.createElement('div');
                page.className = 'ancient-page';
                page.innerHTML = `
                    <div class="inner-border-box"></div>
                    <div class="banxin-container">
                        <div class="thick-line"></div>
                        <div class="banxin-name">李韵天</div>
                        <div class="bottom-lines-wrapper">
                            <div class="thin-line"></div>
                            <div class="thick-line"></div>
                        </div>
                    </div>
                    <div class="content-half content-right"></div>
                    <div class="content-half content-left"></div>
                    <div class="nushu-stamp">
                        <a href="index.html">
                            <img src="https://raw.githubusercontent.com/YuntianAyniLI/YuntianAyniLI.github.io/main/NametaginNyuShu.png" alt="English" class="nushu-img">
                        </a>
                    </div>
                `;
                bookContainer.appendChild(page);
                return page;
            }

            let currentPage = createNewPage();
            let currentRight = currentPage.querySelector('.content-right');
            let currentLeft = currentPage.querySelector('.content-left');
            let targetContainer = currentRight;

            // 核心排版循环：只要还有块没处理完，就继续
            while (blocks.length > 0) {
                let block = blocks.shift(); // 取出第一个块

                // 1. 处理强制换列标记
                if (block.classList.contains('break-to-left') && targetContainer === currentRight) {
                    targetContainer = currentLeft;
                }

                // 2. 尝试放入容器
                targetContainer.appendChild(block);

                // 3. 检查是否溢出或碰撞
                let overflowType = checkOverflowOrCollision(block, targetContainer, currentPage);

                if (overflowType) {
                    // 如果有问题，进行切割
                    // console.log('Overflow detected:', overflowType);
                    
                    // 核心拆分逻辑：把放得下的留下，放不下的切出来
                    let remainder = splitBlockToFit(block, targetContainer, currentPage);
                    
                    if (remainder) {
                        // 如果切出了剩余部分，把它放回队列头部，下次处理
                        blocks.unshift(remainder);
                    }

                    // 切换到下一个容器
                    if (targetContainer === currentRight) {
                        targetContainer = currentLeft;
                    } else {
                        // 左边也满了，建新页
                        currentPage = createNewPage();
                        currentRight = currentPage.querySelector('.content-right');
                        currentLeft = currentPage.querySelector('.content-left');
                        targetContainer = currentRight;
                    }
                }
            }
        }

        // 检测函数：返回 'width' (溢出边界) 或 'collision' (撞到图片) 或 null (正常)
        function checkOverflowOrCollision(block, container, page) {
            // 1. 宽度溢出检测 (竖排的横向溢出)
            // 给5px容差
            if (container.scrollWidth > container.clientWidth + 5) {
                return 'width';
            }

            // 2. 图片碰撞检测 (仅左侧容器需要)
            if (container.classList.contains('content-left')) {
                const nodeRect = block.getBoundingClientRect();
                const pageRect = page.getBoundingClientRect();

                // 离页面左边缘的距离
                const distanceToLeft = nodeRect.left - pageRect.left;
                // 离页面下边缘的距离
                const distanceToBottom = pageRect.bottom - nodeRect.bottom;

                // 危险区域：左100px, 下115px (图片区域)
                if (distanceToLeft < 100 && distanceToBottom < 115) {
                    return 'collision';
                }
            }
            return null;
        }

        // 拆分函数：二分法查找断点，返回剩余部分的节点
        function splitBlockToFit(block, container, page) {
            // 如果块里只有纯文本（简单情况）
            // 或者结构比较简单。这里我们采用“逐字删除直到适配”的倒序策略。
            
            // 复制一份原始内容，用于稍后恢复剩余部分
            let originalContent = block.innerHTML;
            let originalClone = block.cloneNode(true);
            
            // 我们需要深入到 block 内部的最后一个文本节点进行切割
            // 为了简化，我们假设最末尾的是文本。如果有嵌套标签（如ge-zhu），逻辑会很复杂。
            // 这里实现一个简易版：不断移除最后一个子节点/字符，直到不溢出。
            
            // 这是一个临时容器，用来存放被切下来的东西（倒序）
            let extractedNodes = []; 

            // 循环直到适配
            while (checkOverflowOrCollision(block, container, page)) {
                let lastChild = block.lastChild;
                if (!lastChild) break; // 删光了

                if (lastChild.nodeType === 3) { // 文本节点
                    let text = lastChild.nodeValue;
                    if (text.length > 0) {
                        // 切下一个字
                        let char = text.slice(-1);
                        lastChild.nodeValue = text.slice(0, -1);
                        // 把字存起来
                        extractedNodes.unshift(document.createTextNode(char));
                        
                        // 如果删空了该节点，移除它
                        if (lastChild.nodeValue.length === 0) {
                            block.removeChild(lastChild);
                        }
                    } else {
                        block.removeChild(lastChild);
                    }
                } else {
                    // 元素节点 (如 span, a, br)
                    // 整个移走
                    block.removeChild(lastChild);
                    extractedNodes.unshift(lastChild);
                }
            }

            // 如果 block 被删空了，说明这个块在这个位置完全放不下
            // 这种情况下，不要切割，直接返回整个块（让它去下一个容器）
            if (block.childNodes.length === 0) {
                container.removeChild(block);
                // 恢复原状返回
                return originalClone;
            }

            // 如果有切下来的东西，组装成一个新的 block
            if (extractedNodes.length > 0) {
                let newBlock = block.cloneNode(false); // 浅拷贝壳子 (class等)
                // 移除 ID 以免重复
                newBlock.removeAttribute('id');
                // 重新填入切下来的内容
                extractedNodes.forEach(node => newBlock.appendChild(node));
                return newBlock;
            }

            return null;
        }

        function styleAllPunctuation() {
            const wrappers = document.querySelectorAll('.content-block, .project-content');
            wrappers.forEach(container => {
                processNode(container);
            });

            function processNode(node) {
                if (node.nodeType === 3) { 
                    const text = node.nodeValue;
                    const regex = /([，、。])/g; 
                    if (regex.test(text)) {
                        const fragment = document.createDocumentFragment();
                        let lastIndex = 0;
                        text.replace(regex, function(match, char, index) {
                            const prevText = text.slice(lastIndex, index);
                            if (prevText) fragment.appendChild(document.createTextNode(prevText));
                            
                            const wrapper = document.createElement('span');
                            wrapper.className = 'punct-wrapper';
                            const punctSpan = document.createElement('span');
                            punctSpan.className = 'punct';
                            
                            if (char === '。') {
                                punctSpan.classList.add('punct-period');
                            } else {
                                punctSpan.classList.add('punct-dun');
                            }
                            
                            wrapper.appendChild(punctSpan);
                            fragment.appendChild(wrapper);
                            lastIndex = index + 1;
                        });
                        const remainingText = text.slice(lastIndex);
                        if (remainingText) fragment.appendChild(document.createTextNode(remainingText));
                        node.parentNode.replaceChild(fragment, node);
                    }
                } else if (node.nodeType === 1 && node.nodeName !== 'SCRIPT' && node.nodeName !== 'A') {
                    Array.from(node.childNodes).forEach(processNode);
                }
            }
        }
    </script>
</body>
</html>
