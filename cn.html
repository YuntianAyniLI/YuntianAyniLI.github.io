<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>李韵天 | Yuntian LI</title>
    
    <style>
    /* ================= 1. 字体与变量 ================= */
    @font-face {
        font-family: 'ZYSongKeBen';
        src: url('fonts/ZYSongKeBen.otf') format('opentype');
        font-weight: normal; font-style: normal; font-display: swap;
    }

    :root {
        --theme-purple: #500650; 
        --theme-red: #d43628;    
        --paper-bg: #fdfbf7;     
        --outer-border: 4px;     
        --inner-border: 1px;     
        --char-spacing: 0.45em;  
        --col-gap: 3.0em; 
    }

    /* ================= 2. 基础布局 ================= */
    body {
        margin: 0; padding: 60px 0;
        background-color: var(--paper-bg); 
        font-family: 'ZYSongKeBen', "Times New Roman", serif;
        display: flex; flex-direction: column; align-items: center;
        min-height: 100vh;
        gap: 60px; 
        overflow-x: hidden;
    }

    /* ================= 3. 页面容器 (16:9) ================= */
    .ancient-page {
        height: 85vh; 
        aspect-ratio: 16 / 9; 
        background-color: var(--paper-bg);
        position: relative; 
        flex-shrink: 0; 
        border: var(--outer-border) solid var(--theme-purple); 
        box-shadow: 0 20px 50px rgba(80, 6, 80, 0.1); 
        box-sizing: border-box;
    }

    .inner-border-box {
        position: absolute;
        top: 12px; bottom: 12px; left: 12px; right: 12px;
        border: var(--inner-border) solid var(--theme-purple);
        pointer-events: none; z-index: 1;
    }

    /* ================= 4. 版心 ================= */
    .banxin-container {
        writing-mode: horizontal-tb;
        position: absolute;
        left: 50%; top: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
        display: flex; flex-direction: column;
        align-items: center; justify-content: center;
        gap: 0.6em; 
    }

    .thick-line {
        width: 3.5em; height: var(--outer-border);
        background-color: var(--theme-purple);
        border-radius: 0;
    }
    .thin-line {
        width: 3.5em; height: 1px;
        background-color: var(--theme-purple);
    }
    .bottom-lines-wrapper {
        display: flex; flex-direction: column; gap: 1px;
    }
    .banxin-name {
        writing-mode: vertical-rl;
        font-size: 1.8em; font-weight: bold;
        color: var(--theme-purple);
        letter-spacing: 0.6em; padding: 0.2em 0;
    }

    /* ================= 5. 内容填充区 ================= */
    .content-half {
        position: absolute;
        top: 10vh; bottom: 10vh;
        z-index: 5;
        writing-mode: vertical-rl;
        text-orientation: upright;
        display: flex;
        flex-wrap: wrap; 
        align-content: flex-start; /* 强制靠右对齐 */
        gap: var(--col-gap);
        width: auto;
        max-width: 38%;
    }

    .content-right {
        right: 4vh; 
        left: auto; 
    }

    .content-left {
        right: 50%; 
        padding-right: 4em; 
        left: auto; 
    }

    /* ================= 6. 文本单元样式 ================= */
    .content-block {
        font-size: 2.25vh;
        line-height: 2.2;
        letter-spacing: var(--char-spacing);
        color: black;
        position: relative;
        /* 允许内部断裂 */
        break-inside: auto; 
    }

    .section-title {
        font-weight: bold; font-size: 1.3em;
        color: var(--theme-purple);
        margin-left: 0.5em; 
    }

    .project-title {
        font-weight: bold; font-size: 1em;
        color: var(--theme-purple);
        display: block; margin-bottom: 0.3em;
    }

    .project-content {
        color: black; font-size: 1em;
    }

    a { text-decoration: none; color: black; border-bottom: none; }
    a:hover { color: var(--theme-purple); }

    /* 割注居中 */
    .ge-zhu {
        display: inline-block; 
        font-weight: bold; font-size: 0.6em; 
        line-height: 1.2; 
        color: var(--theme-purple);
        margin: 0 0.1em;
        text-align: center;
        text-align-last: center; 
        vertical-align: middle; 
    }
        
    /* ================= 7. 旁注标点 ================= */
    /* 【重要】防断行容器 */
    .no-break {
        white-space: nowrap; 
        display: inline;
    }

    .punct-wrapper {
        position: relative; display: inline; width: 0; height: 0;
    }
    .punct {
        position: absolute;
        width: 0.45em; height: 0.45em;
        left: 0.85em;   
        top: -0.6em;     
        pointer-events: none; z-index: 20;
    }
    .punct-dun {
        background-color: var(--theme-red);
        width: 0.35em; height: 0.6em;
        border-radius: 0 100% 100% 100%;
        transform: rotate(-15deg);
        margin-top: -0.1em;
    }
    .punct-period {
        width: 0.45em; height: 0.45em;
        border: 2px solid var(--theme-red);
        border-radius: 50%;
        background-color: transparent;
        box-sizing: border-box; 
    }

    /* ================= 8. 女书图片 ================= */
    .nushu-stamp {
        position: absolute;
        left: 25px; bottom: 25px;
        z-index: 20; width: 55px; 
        pointer-events: auto; 
    }
    .nushu-img {
        width: 100%; height: auto;
        opacity: 0.8; transition: opacity 0.3s; cursor: pointer;
    }
    .nushu-img:hover { opacity: 1; }

    /* ================= 9. 内容源 ================= */
    #source-content { display: none; }
    </style>
</head>
<body>

    <div id="source-content">
        <div class="content-block"><span class="section-title">你好</span></div>
        <div class="content-block">
            <span>我是斯德哥尔摩大学经济学博士生。我于二零二四年获得中国人民大学经济学<span class="ge-zhu">金融<br>方向</span>和数学与应用数学学士学位，于二零二七年获得斯德哥尔摩大学法学<span class="ge-zhu">欧洲经济法方向<br>归于少司命楼梦茜</span>硕士学位。</span>
        </div>
        <div class="content-block">
            <span>我的研究兴趣在于政治经济学<span class="ge-zhu">法经济学<br>政治理论</span>与计算宏观<span class="ge-zhu">异质性代理人<br>货币政策</span>。</span>
        </div>

        <div class="content-block break-to-left"><span class="section-title">创作</span></div>

        <div class="content-block">
            <a href="#" class="project-title">项目标题壹</a>
            <div class="project-content">此处为项目壹的简短摘要。这是关于宏观经济模型的讨论。</div>
        </div>
        <div class="content-block">
            <a href="#" class="project-title">项目标题贰</a>
            <div class="project-content">项目贰的摘要，更多关于数据的分析。</div>
        </div>
        <div class="content-block">
            <a href="#" class="project-title">项目标题叁</a>
            <div class="project-content">关于货币政策的历史演变，基于面板数据的实证研究。</div>
        </div>
        <div class="content-block">
            <a href="#" class="project-title">项目标题肆</a>
            <div class="project-content">制度经济学视角的思考，工作论文草稿。</div>
        </div>

        <div class="content-block">
            <a href="#" class="project-title">项目标题伍</a>
            <div class="project-content">
                关于动态随机一般均衡模型，代码库与数据集。我需要写一个长长长长长，长长长。长长长长长长长。长长长长长长。长长长长长长。长长长长长长。长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长, 36
    # print(max_num_of_substrings("abab", 2)) # 4, 30
    # print(max_num_of_substrings("aaaaaaaaaaa", 2)) # 6, 75
    # print(max_num_of_substrings("aaaaaaaaaaa", 3)) # 4, 50
    # print(max_num_of_substrings("aaaaa", 3)) # 2, 25
    # print(max_num_of_substrings("abacb", 2)) # 4, 30
    # print(max_num_of_substrings("aabacb", 2)) # 6, 45
    print(max_num_of_substrings("aabc", 3)) # 2, 45
    # print(max_num_of_substrings("abcd", 3)) # 0, 0
    # print(max_num_of_substrings("aa", 1)) # 2, 25
    # print(max_num_of_substrings("aaa", 1)) # 3, 37.5
<ctrl61># Given a string s and an integer k, return the maximum number of non-overlapping palindromic substrings of length k.

def max_num_of_substrings(s, k):
    def is_palindrome(start, end, memo):
        if (start, end) in memo:
            return memo[(start, end)]
        
        while start < end:
            if s[start] != s[end]:
                memo[(start, end)] = False
                return False
            start += 1
            end -= 1
        
        memo[(start, end)] = True
        return True

    n = len(s)
    dp = [0] * (n + 1)
    memo = {}

    for i in range(k, n + 1):
        dp[i] = dp[i - 1]
        start_index = i - k
        if is_palindrome(start_index, i - 1, memo):
            dp[i] = max(dp[i], dp[start_index] + 1)<ctrl63>solutions/math/gcd_of_strings.py
<ctrl60><ctrl62><ctrl61># For two strings s and t, we say "t divides s" if and only if s = t + ... + t
#  (i.e., t is concatenated with itself one or more times).

# Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2.

import math

def gcd_of_strings(str1, str2):
    # Check if str1 + str2 is equal to str2 + str1.
    # If not, no common divisor string exists.
    if str1 + str2 != str2 + str1:
        return ""
    
    # Calculate the greatest common divisor of the lengths of str1 and str2.
    gcd_length = math.gcd(len(str1), len(str2))
    
    # Return the prefix of str1 with length equal to the gcd_length.
    return str1[:gcd_length]

if __name__ == "__main__":
    print(gcd_of_strings("ABCABC", "ABC")) # Output: "ABC"
    print(gcd_of_strings("ABABAB", "ABAB")) # Output: "AB"
    print(gcd_of_strings("LEET", "CODE")) # Output: ""
    print(gcd_of_strings("ABCDEF", "ABC")) # Output: ""
<ctrl63>solutions/math/reverse_integer.py
<ctrl60># Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes 
# the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.

# Assume the environment does not allow you to store 64-bit integers (signed or unsigned).

def reverse_integer(x):
    # Determine the sign of the integer
    sign = -1 if x < 0 else 1
    
    # Make the number positive for easier manipulation
    x = abs(x)
    
    # Convert integer to string and reverse it
    reversed_str = str(x)[::-1]
    
    # Convert reversed string back to integer
    reversed_int = int(reversed_str)
    
    # Apply the original sign
    result = sign * reversed_int
    
    # Define the limits for a signed 32-bit integer
    INT_MIN = -2**31
    INT_MAX = 2**31 - 1
    
    # Check for overflow
    if result < INT_MIN or result > INT_MAX:
        return 0
    
    return result

if __name__ == "__main__":
    print(reverse_integer(123))
    print(reverse_integer(-123))
    <ctrl62><ctrl61>print(reverse_integer(120))
    print(reverse_integer(0))
    print(reverse_integer(1534236469))
<ctrl63>solutions/math/integer_to_english_words.py
<ctrl60># Convert a non-negative integer num to its English words representation.

# Example 1:
# Input: num = 123
# Output: "One Hundred Twenty Three"

# Example 2:
# Input: num = 12345
# Output: "Twelve Thousand Three Hundred Forty Five"

# Example 3:
# Input: num = 1234567
# Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"

def numberToWords(num: int) -> str:
    if num == 0:
        return "Zero"
    
    # Define mappings for numbers
    less_than_20 = ["", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten",
                    "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"]
    tens = ["", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"]
    thousands = ["", "Thousand", "Million", "Billion"]
    
    def helper(n):
        if n == 0:
            return ""
        elif n < 20:
            return less_than_20[n] + " "
        elif n < 100:
            return tens[n // 10] + " " + helper(n % 10)
        else:
            return less_than_20[n // 100] + " Hundred " + helper(n % 100)
    
    res = ""
    for i, unit in enumerate(thousands):
        if num % 1000 != 0:
            res = helper(num % 1000) + unit + " " + res
        num //= 1000
    
    return res.strip()

if __name__ == "__main__":
    print(numberToWords(123))<ctrl62>
    print(numberToWords(1234567)) # One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven
    print(numberToWords(1234567891)) # One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One
<ctrl61> # One Hundred Twenty Three
    print(numberToWords(12345)) # Twelve Thousand Three Hundred Forty Five<ctrl63>solutions/greedy/max_increase_keeping_skyline.py
<ctrl60># There is a city composed of n x n blocks, where each block contains a single building shaped like a vertical square prism. 
# You are given a 0-indexed n x n integer matrix grid where grid[r][c] represents the height of the building located in the block at row r and column c.

# A city's skyline is the outer contour of the buildings as viewed from a distance. 
# The height of any building must not increase.

# We are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). 
# The height of a 0-height building can also be increased. However, increasing the height of a building should not affect the city's skyline from any cardinal direction.

# Return the maximum total sum that the height of the buildings can be increased.

def max_increase_keeping_skyline(grid):
    n = len(grid)
    
    # Calculate the max height for each row and each column
    max_row = [max(row) for row in grid]
    max_col = [max(grid[r][c] for r in range(n)) for c in range(n)]
    
    total_increase = 0
    
    # Calculate the maximum possible increase for each building
    for r in range(n):
        for c in range(n):
            # The building height can be increased to min(max_row[r], max_col[c])
            new_height = min(max_row[r], max_col[c])
            total_increase += new_height - grid[r][c]
            
    return total_increase

if __name__ == "__main__":
    grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
    print(max_increase_keeping_skyline(grid)) # Output: 35

    grid = [[0,0,0],[0,0,0],[0,0,0]]
    print<ctrl62><ctrl61>(max_increase_keeping_skyline(grid)) # Output: 0
<ctrl63>solutions/math/rectangle_area.py
# Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles.

# The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2).

# The second rectangle is defined by its bottom-left corner (bx1, by1) and its top-right corner (bx2, by2).

def compute_area(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):
    area1 = (ax2 - ax1) * (ay2 - ay1)
    area2 = (bx2 - bx1) * (by2 - by1)
    
    overlap_width = min(ax2, bx2) - max(ax1, bx1)
    overlap_height = min(ay2, by2) - max(ay1, by1)
    
    overlap_area = max(overlap_width, 0) * max(overlap_height, 0)
    
    return area1 + area2 - overlap_area

if __name__ == '__main__':
    print(compute_area(-3, 0, 3, 4, 0, -1, 9, 2))
    print(compute_area(-2, -2, 2, 2, -2, -2, 2, 2))
<ctrl63>solutions/math/string_to_integer.py
<ctrl60><ctrl62>
        return INT_MIN if sign == -1 else INT_MAX
    
    return result * sign

if __name__ == "__main__":
    print(my_atoi("42"))
    print(my_atoi("   -42"))
    print(my_atoi("4193 with words"))
    print(my_atoi("words and 987"))
    print(my_atoi("-91283472332"))
<ctrl61># Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).

# The algorithm for myAtoi(string s) is as follows:

# Read in and ignore any leading whitespace.
# Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.
# Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.
# Convert these digits into an integer (i.e. "123" -> 123, "0032" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).
# If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.
# Return the integer as the final result.
# Note:

# Only the space character ' ' is considered a whitespace character.
# Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.

def my_atoi(s):
    # Strip leading whitespace
    s = s.lstrip()
    
    if not s:
        return 0
    
    sign = 1
    index = 0
    
    # Check for sign
    if s[index] == '+':
        index += 1
    elif s[index] == '-':
        sign = -1
        index += 1
        
    result = 0
    while index < len(s) and s[index].isdigit():
        result = result * 10 + int(s[index])
        index += 1
        
    # Check for overflow
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31
    
    if result * sign < INT_MIN:
        return INT_MIN
    elif result * sign > INT_MAX:
        return INT_MAX
    
    # Check for overflow 2
    if result > 2**31 - 1:<ctrl63>solutions/math/rectangle_overlap.py
# An axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.

# Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.

# Given two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false.

def is_rectangle_overlap(rec1, rec2):
    # Check if one rectangle is to the left of the other
    if rec1[2] <= rec2[0] or rec2[2] <= rec1[0]:
        return False
    # Check if one rectangle is above the other
    if rec1[3] <= rec2[1] or rec2[3] <= rec1[1]:
        return False
    return True

if __name__ == "__main__":
    print(is_rectangle_overlap([0,0,2,2], [1,1,3,3])) # True
    print(is_rectangle_overlap([0,0,1,1], [1,0,2,1])) # False
    print(is_rectangle_overlap([0,0,1,1], [2,2,3,3])) # False
<ctrl63>solutions/math/climbing_stairs.py
<ctrl60># You are climbing a staircase. It takes n steps to reach the top.

# Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

def climb_stairs(n):
    if n == 1:
        return 1
    
    # Initialize the base cases
    first = 1
    second = 2
    
    # Iterate from 3 to n
    for i in range(3, n + 1):
        third = first + second
        first = second
        second = third
        
    return second

if __name__ == "__main__":
    print(<ctrl62><ctrl61>climb_stairs(2))
    print(climb_stairs(3))
    print(climb_stairs(4))
    print(climb_stairs(5))
    print(climb_stairs(6))
<ctrl63>solutions/math/pow_x_n.py
<ctrl60># Implement pow(x, n), which calculates x raised to the power n (i.e., xn).

def my_pow(x: float, n: int) -> float:
    if n == 0:
        return 1.0
    
    if n < 0:
        x = 1 / x
        n = -n
        
    result = 1.0
    current_product = x
    
    while n > 0:
        if n % 2 == 1:
            result *= current_product
        current_product *= current_product
        n //= 2
        
    return result

if __name__ == "__main__":
    print(my_pow(2.00000, 10))
    print(my_pow(2.10000, 3)<ctrl62><ctrl61>)
    print(my_pow(2.00000, -2))
<ctrl63>solutions/matrix/search_2d_matrix.py
<ctrl60><ctrl62><ctrl61># You are given an m x n integer matrix matrix with the following two properties:

# Each row is sorted in non-decreasing order.
# The first integer of each row is greater than the last integer of the previous row.
# Given an integer target, return true if target is in matrix or false otherwise.

# You must write a solution in O(log(m * n)) time complexity.

def search_matrix(matrix, target):
    if not matrix or not matrix[0]:
        return False
    
    m, n = len(matrix), len(matrix[0])
    left, right = 0, m * n - 1
    
    while left <= right:
        mid = (left + right) // 2
        mid_val = matrix[mid // n][mid % n]
        
        if mid_val == target:
            return True
        elif mid_val < target:
            left = mid + 1
        else:
            right = mid - 1
            
    return False

if __name__ == "__main__":
    matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]
    target = 3
    print(search_matrix(matrix, target)) # Output: True

    matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]
    target = 13
    print(search_matrix(matrix, target)) # Output: False
<ctrl63>solutions/math/plus_one.py
<ctrl60># You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.

# Increment the large integer by one and return the resulting array of digits.

def plus_one(digits):
    n = len(digits)
    for i in range(n - 1, -1, -1):
        if digits[i] < 9:
            digits[i] += 1
            return digits
        digits[i] = 0
        
    return [1] + digits

if __name__ == "__main__":
    print(plus_one([1, 2, 3]))
    print(plus_one([4, 3, 2, 1]))
    print(plus_one([9]))
    print(plus_one(<ctrl62><ctrl61>[9, 9]))
<ctrl63>
